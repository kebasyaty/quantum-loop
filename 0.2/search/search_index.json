{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantum Loop","text":"<p> A set of tools for quantum calculations. <p> </p> </p> <p></p> <p>   A set of tools for quantum calculations.      A Qubit in a regular computer is quantum of algorithm that is executed in   one iteration of a cycle in a separate processor thread.       Quantum is a function with an algorithm of task for data processing.       In this case, the Qubit is not a single information,      but it is a concept of the principle of operation of quantum calculations on a regular computer. </p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add quantum-loop\n</code></pre>"},{"location":"pages/loop/","title":"Loop","text":"<p>A set of tools for quantum calculations.</p> <p>A Qubit in a regular computer is quantum of algorithm that is executed in one iteration of a cycle in a separate processor thread.</p> <p>Quantum is a function with an algorithm of task for data processing.</p> <p>In this case, the Qubit is not a single information, but it is a concept of the principle of operation of quantum calculations on a regular computer.</p> <p>The module contains the following tools:</p> <ul> <li><code>QuantumLoop</code> - Separation of the cycle into quantum algorithms for multiprocessing data processing.</li> </ul>"},{"location":"pages/loop/#ql.loop.QuantumLoop","title":"<code>QuantumLoop</code>","text":"<p>Separation of the cycle into quantum algorithms for multiprocessing data processing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ql import QuantumLoop\n&gt;&gt;&gt; def task(num: int) -&gt; int | None:\n... return num * num if num % 2 == 0 else None\n&gt;&gt;&gt; data = range(1, 10)\n&gt;&gt;&gt; QuantumLoop(task, data).run()\n[4, 16, 36, 64]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Callable</code> <p>Function with a task algorithm.</p> required <code>data</code> <code>Iterable[Any]</code> <p>The data that needs to be processed.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <code>mode</code> <code>LoopMode</code> <p>The operating mode for a quantum loop: LoopMode.PROCESS_POOL | LoopMode.THREAD_POOL.</p> <code>PROCESS_POOL</code> Source code in <code>src\\ql\\loop.py</code> <pre><code>class QuantumLoop:\n    \"\"\"Separation of the cycle into quantum algorithms for multiprocessing data processing.\n\n    Examples:\n        &gt;&gt;&gt; from ql import QuantumLoop\n        &gt;&gt;&gt; def task(num: int) -&gt; int | None:\n        ... return num * num if num % 2 == 0 else None\n        &gt;&gt;&gt; data = range(1, 10)\n        &gt;&gt;&gt; QuantumLoop(task, data).run()\n        [4, 16, 36, 64]\n\n    Args:\n        task: Function with a task algorithm.\n        data: The data that needs to be processed.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n        mode: The operating mode for a quantum loop: LoopMode.PROCESS_POOL | LoopMode.THREAD_POOL.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        task: Callable,\n        data: Iterable[Any],\n        max_workers: int | None = None,\n        timeout: float | None = None,\n        mode: LoopMode = LoopMode.PROCESS_POOL,\n    ) -&gt; None:\n        self.task = task\n        self.data = data\n        self.max_workers = max_workers\n        self.timeout = timeout\n        self.mode = mode\n\n    def process_pool(self) -&gt; list[Any]:\n        \"\"\"Better suitable for operations for which large processor resources are required.\"\"\"\n        task = self.task\n        data = self.data\n        timeout = self.timeout\n        results: list[Any] = []\n        with concurrent.futures.ProcessPoolExecutor(self.max_workers) as executor:\n            for item in data:\n                future = executor.submit(task, item)\n                result = future.result(timeout)\n                if result is not None:\n                    results.append(result)\n        return results\n\n    def thread_pool(self) -&gt; list[Any]:\n        \"\"\"More suitable for tasks related to input-output\n        (for example, network queries, file operations),\n        where GIL is freed during input-output operations.\"\"\"  # noqa: D205, D209\n        task = self.task\n        data = self.data\n        timeout = self.timeout\n        results: list[Any] = []\n        with concurrent.futures.ThreadPoolExecutor(self.max_workers) as executor:\n            for item in data:\n                future = executor.submit(task, item)\n                result = future.result(timeout)\n                if result is not None:\n                    results.append(result)\n        return results\n\n    def run(self) -&gt; list[Any]:\n        \"\"\"Run the quantum loop.\"\"\"\n        results: list[Any] = []\n        match self.mode.value:\n            case 1:\n                results = self.process_pool()\n            case 2:\n                results = self.thread_pool()\n            case _ as unreachable:\n                assert_never(Never(unreachable))\n        return results\n</code></pre>"},{"location":"pages/loop/#ql.loop.QuantumLoop.process_pool","title":"<code>process_pool()</code>","text":"<p>Better suitable for operations for which large processor resources are required.</p> Source code in <code>src\\ql\\loop.py</code> <pre><code>def process_pool(self) -&gt; list[Any]:\n    \"\"\"Better suitable for operations for which large processor resources are required.\"\"\"\n    task = self.task\n    data = self.data\n    timeout = self.timeout\n    results: list[Any] = []\n    with concurrent.futures.ProcessPoolExecutor(self.max_workers) as executor:\n        for item in data:\n            future = executor.submit(task, item)\n            result = future.result(timeout)\n            if result is not None:\n                results.append(result)\n    return results\n</code></pre>"},{"location":"pages/loop/#ql.loop.QuantumLoop.run","title":"<code>run()</code>","text":"<p>Run the quantum loop.</p> Source code in <code>src\\ql\\loop.py</code> <pre><code>def run(self) -&gt; list[Any]:\n    \"\"\"Run the quantum loop.\"\"\"\n    results: list[Any] = []\n    match self.mode.value:\n        case 1:\n            results = self.process_pool()\n        case 2:\n            results = self.thread_pool()\n        case _ as unreachable:\n            assert_never(Never(unreachable))\n    return results\n</code></pre>"},{"location":"pages/loop/#ql.loop.QuantumLoop.thread_pool","title":"<code>thread_pool()</code>","text":"<p>More suitable for tasks related to input-output (for example, network queries, file operations), where GIL is freed during input-output operations.</p> Source code in <code>src\\ql\\loop.py</code> <pre><code>def thread_pool(self) -&gt; list[Any]:\n    \"\"\"More suitable for tasks related to input-output\n    (for example, network queries, file operations),\n    where GIL is freed during input-output operations.\"\"\"  # noqa: D205, D209\n    task = self.task\n    data = self.data\n    timeout = self.timeout\n    results: list[Any] = []\n    with concurrent.futures.ThreadPoolExecutor(self.max_workers) as executor:\n        for item in data:\n            future = executor.submit(task, item)\n            result = future.result(timeout)\n            if result is not None:\n                results.append(result)\n    return results\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<pre><code>from ql import QuantumLoop, count_qubits\n\n\ndef task(num: int) -&gt; int | None:\n    \"\"\"Quantum.\"\"\"\n    return num * num if num % 2 == 0 else None\n\n\ndef main() -&gt; None:\n    # Counting the number of conceptual qubits of your computer.\n    num = count_qubits()\n    print(num)  # =&gt; 16\n\n    # Separation of the cycle into quantum algorithms for\n    # multiprocessing data processing.\n    data = range(1, 10)\n    results = QuantumLoop(task, data).run()\n    print(results)  # =&gt; [4, 16, 36, 64]\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"pages/utils/","title":"Utils","text":"<p>Utils.</p> <p>The module contains the following tools:</p> <ul> <li><code>LoopMode</code> - Quantum loop mode.</li> <li><code>count_qubits()</code> - Counting the number of conceptual qubits of your computer.</li> </ul>"},{"location":"pages/utils/#ql.utils.LoopMode","title":"<code>LoopMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Quantum loop mode.</p> Source code in <code>src\\ql\\utils.py</code> <pre><code>class LoopMode(Enum):\n    \"\"\"Quantum loop mode.\"\"\"\n\n    PROCESS_POOL = 1\n    THREAD_POOL = 2\n</code></pre>"},{"location":"pages/utils/#ql.utils.count_qubits","title":"<code>count_qubits()</code>","text":"<p>Counting the number of conceptual qubits of your computer.</p> <p>Conceptual qubit is quantum of algorithm (task) that is executed in iterations of a cycle in a separate processor thread.</p> <p>Quantum of algorithm is a function for data processing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ql import count_qubits\n&gt;&gt;&gt; count_qubits()\n16\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The number of conceptual qubits.</p> Source code in <code>src\\ql\\utils.py</code> <pre><code>def count_qubits() -&gt; int:\n    \"\"\"Counting the number of conceptual qubits of your computer.\n\n    Conceptual qubit is quantum of algorithm (task) that is executed in\n    iterations of a cycle in a separate processor thread.\n\n    Quantum of algorithm is a function for data processing.\n\n    Examples:\n        &gt;&gt;&gt; from ql import count_qubits\n        &gt;&gt;&gt; count_qubits()\n        16\n\n    Returns:\n        The number of conceptual qubits.\n    \"\"\"\n    return multiprocessing.cpu_count()\n</code></pre>"}]}